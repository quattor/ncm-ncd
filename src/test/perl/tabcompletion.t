use strict;
use warnings;

#
# This is based in the CCM tabcompletion.t
#

use Test::More;
use CAF::Process;
use CAF::FileWriter;
use Readonly;
use File::Path qw(mkpath rmtree);
use Test::Quattor::ProfileCache;
use Test::Quattor::TextRender::Base;
use EDG::WP4::CCM::Path qw(set_safe_unescape reset_safe_unescape);
use EDG::WP4::CCM::TextRender qw(ccm_format);
use NCD::CLI qw(@SUPPORTED_REPORT_FORMATS);
use Cwd qw(getcwd abs_path);
use File::Copy;

use Test::MockModule;
my $mock_cli = Test::MockModule->new('NCD::CLI');
$mock_cli->mock('_get_uid', 0);

# Do not mock the renderer, use the one from CCM
# try source relative to current path (eg on jenkins) and default install
my $tt_ccm = abs_path(getcwd().'/../CCM/src/main/resources');
ok(-d $tt_ccm, "Did not find the CCM TT directory $tt_ccm");

my $default_install = '/usr/share/templates/quattor';

my @paths;
if (-d $tt_ccm) {
    my $local_tt = 'target/TT';
    my $local_tt_ccm = "$local_tt/CCM";
    mkdir($local_tt);
    mkdir($local_tt_ccm);
    # copy all .tt to
    foreach my $fn (glob("$tt_ccm/*.tt")) {
        copy $fn, $local_tt_ccm;
    };
    push(@paths, abs_path($local_tt));
}

push(@paths, $default_install) if -d $default_install;
my $caf_trd = mock_textrender(\@paths);

# manually keep up to date?
Readonly my $CCM_TAB_COMP => 'src/test/resources/quattor-ccm';
Readonly my $TAB_COMP => 'target/etc/bash_completion.d/ncm-ncd.sh';

# Do this by hand, tabcompletion data is not generated by the test framework
my $cfg = prepare_profile_cache('tabcompletion');

my $fh = CAF::FileWriter->new("$cfg->{cache_path}/ccm.conf");
print $fh "cache_root $cfg->{cache_path}\n";
$fh->close();

my $el = $cfg->getElement('/');
set_safe_unescape();
my $fmt = ccm_format('tabcompletion', $el);
reset_safe_unescape();
diag("$fmt");

$fh = CAF::FileWriter->new("$cfg->{cfg_path}/tabcompletion");
print $fh "$fmt";
$fh->close();

# ordered by ls; fake cids (active one is 2)
my @cids = qw(1 10 100 11 110 111 112 2 3);
foreach my $cid (@cids) {
    mkpath("$cfg->{cache_path}/profile.$cid");
}

# create subtree with some files and directories to test compgen -f/-d
Readonly my $COMPGEN_BASE => "target/test/tabcompletion/compgen";
mkpath($COMPGEN_BASE);

my @compgen_dirs = qw(dir1 dir2);
my $compgen_dirs_full = [sort map {"$COMPGEN_BASE/$_"} @compgen_dirs];
foreach my $dir (@compgen_dirs) {
    mkpath("$COMPGEN_BASE/$dir");
}

my @compgen_files = qw(file1 file2);
foreach my $file (@compgen_files) {
    $fh = CAF::FileWriter->new("$COMPGEN_BASE/$file");
    print $fh "$file\n";
    $fh->close();
}
# add the dirs, they will also be considered for -f output
push(@compgen_files, @compgen_dirs);
my $compgen_files_full = [sort map {"$COMPGEN_BASE/$_"} @compgen_files];


sub run_bash
{
    my ($args, $echo_comp) = @_;

    my $p = CAF::Process->new(['bash', '-c']);

    # Source CCM_TAB_COMP by hand before
    my @bashargs = ("QUATTOR_CCM_CONF=$cfg->{cache_path}/ccm.conf",
                    'source', $CCM_TAB_COMP, '&&',
                    'source', $TAB_COMP, '&&' );
    push (@bashargs, @$args);

    push(@bashargs, '&&', 'echo', '${COMPREPLY[@]}') if $echo_comp;

    $p->pushargs(join(" ", @bashargs));

    my $output = $p->output();
    chomp($output);

    diag("Ran $p output $output.");
    return $output, "$p";
}

sub test_bash
{
    my ($test, $msg, $args, $echo_comp) = @_;

    my ($output, $cmdline) = run_bash($args, $echo_comp);

    if (ref($test) eq "ARRAY") {
        my @res = sort split(qr{\s+}, $output);
        is_deeply(\@res, $test, "$msg with $cmdline (test sorted results)");
    } else {
        like($output, $test, "$msg with $cmdline");
    }
}

sub test_func
{
    my ($test, $msg, @args) = @_;
    test_bash($test, $msg, \@args);
}

sub test_comp
{
    my ($test, $msg, @args) = @_;
    test_bash($test, $msg, \@args, 1);
}

# test the existence of the _quattor_ncm_ncd_longoptions variable
# it is used in quattor-ccm-profile script, and must exist to avoid reloading
like((run_bash(['echo', '$_quattor_ncm_ncd_longoptions']))[0], qr{^--},
     "_quattor_ncm_ncd_longoptions variable is not empty");

# Test options tabcompletions lists
sub bash_split_opts
{
    my ($varname) = @_;
    my ($output, $cmdline) = run_bash(['echo', '${'.$varname.'[@]}']);
    my @opts = sort split(qr{\s+}, $output);
    return \@opts;
}

# from CAF::Application
Readonly::Array my @CAF_OPTIONS => qw(debug help quiet verbose version);
is_deeply(bash_split_opts('_quattor_ncm_ncd_default_options'),
          \@CAF_OPTIONS,
          "_quattor_ncm_ncd_default_options");

Readonly::Array my @OPTIONS => qw(all allowbrokencomps autodeps cache_root cfgfile
check-noquattor chroot configure facility force-quattor forcelock history history-instances
ignore-errors-from-dependencies ignorelock include list
log_group_readable log_world_readable logdir logpid multilog noaction nodeps
post-hook post-hook-timeout pre-hook pre-hook-timeout report report-format retries
skip state timeout unconfigure useprofile verbose_logfile);

is_deeply(bash_split_opts('_quattor_ncm_ncd_options'),
          \@OPTIONS,
          "_quattor_ncm_ncd_options");

my $nooptions = [qw(no-autodeps no-check-noquattor)];
is_deeply(bash_split_opts('_quattor_ncm_ncd_no_options'),
          $nooptions,
          "_quattor_ncm_ncd_no_options");

is_deeply(bash_split_opts('_quattor_ncm_ncd_report_formats'),
          \@SUPPORTED_REPORT_FORMATS,
          "_quattor_ncm_ncd_report_formats");

sub NAME_to_opt
{
    # each arg is a NAME element, eg name|alias|<singlelettershorthand>=something
    my @res;
    foreach my $option (@_) {
        my $nametxt = [split(qr{=|:|!}, $option->{NAME})]->[0];
        my @names = split(qr{\|}, $nametxt);
        # remove single letter option
        push(@res, grep {length($_) != 1} @names);
    };
    return @res;
}

my $cli = NCD::CLI->new('test', '--logdir', 'target');
diag "default options ", join(" ",sort(NAME_to_opt(@{$cli->_app_default_options()})));
diag "options ", join(" ",sort(NAME_to_opt(@{$cli->app_options()})));
my $longopts = [sort map {"--$_"} (NAME_to_opt(@{$cli->app_options()}, @{$cli->_app_default_options()}), @$nooptions)];
is_deeply([sort @{bash_split_opts('_quattor_ncm_ncd_longoptions')}],
          $longopts,
          "_quattor_ncm_ncd_longoptions");

# all components
test_comp([qw(bar foo)],
          "Tabcomplete _ncm_ncd",
          'COMP_WORDS=(SCRIPTNAME)', 'COMP_CWORD=1', '&&', '_ncm_ncd');

# tabcomplete component
test_comp([qw(foo)],
          "Tabcomplete _ncm_ncd f",
          'COMP_WORDS=(SCRIPTNAME f)', 'COMP_CWORD=1', '&&', '_ncm_ncd');

# all options
test_comp($longopts,
          "Tabcomplete _ncm_ncd -",
          'COMP_WORDS=(SCRIPTNAME -)', 'COMP_CWORD=1', '&&', '_ncm_ncd');

# cids
test_comp(\@cids,
          "Tabcomplete _ncm_ncd --useprofile",
          'COMP_WORDS=(SCRIPTNAME --useprofile)', 'COMP_CWORD=2', '&&', '_ncm_ncd');

# report-format
test_comp(\@SUPPORTED_REPORT_FORMATS,
          "Tabcomplete _ncm_ncd --report-format",
          'COMP_WORDS=(SCRIPTNAME --report-format)', 'COMP_CWORD=2', '&&', '_ncm_ncd');

# test binding
test_bash(qr{^complete -F _ncm_ncd ncm-ncd$}m,
          "tabcompletion function _ncm_ncd for ncm-ncd command",
          ["complete", "-p"]);
test_bash(qr{^complete -F _ncm_ncd quattor-unconfigure$}m,
          "tabcompletion function _ncm_ncd for quattor-unconfigure command",
          ["complete", "-p"]);
test_bash(qr{^complete -F _ncm_ncd quattor-configure$}m,
          "tabcompletion function _ncm_ncd for quattor-configure command",
          ["complete", "-p"]);
test_bash(qr{^complete -F _ncm_ncd quattor-list$}m,
          "tabcompletion function quattor-list command",
          ["complete", "-p"]);

done_testing();
